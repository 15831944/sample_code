
#include <vgStableHeaders.h>
#include "vgObjectSet.h"

// t3DModel		//////////////////////////////////////////////////////////////////////
t3DModel::t3DModel()
{
	m_nObjectCount	= m_nTotalFaceCount = 0;
	memset( m_strModelName, 0, sizeof(m_strModelName) );
	memset( m_strFileName, 0, sizeof(m_strFileName) );
	m_pFile = NULL;
	m_puObjPos = NULL;
	m_uiObjPosPos = 0;
	m_pMaxInterface	= NULL;

	initilize();
}
t3DModel::~t3DModel()
{
	reset();
}
void	t3DModel::push_back(t3DObject* pObject)
{
	m_vObject.push_back(pObject);
	m_vObjectType.push_back(pObject->m_nObjectType);
	m_vIsBaked.push_back(pObject->m_bIsBaked);
}
int		t3DModel::size()
{
	return	(int)m_vObject.size();
}

bool	t3DModel::Write(FILE* pFile, MeshMtlList* pMeshList, Interface* pMaxInterface
						, TCHAR* pFormat, int nVersionMod/* = VERSION_MOD_CURRENT*/)
{
	m_pFile = pFile;
	m_pTheMtls = pMeshList;
	m_pMaxInterface = pMaxInterface;
	_tcsncpy_s(m_sFormat, sizeof(m_sFormat), pFormat, sizeof(m_sFormat));
	m_nVersionMod = nVersionMod;

	//	Part 0: 物体属性
	writeFormat();
	
	//	Part 1: 物体属性
	writeHeader();

	//	Part 2: 模型数据
	writeObjects();

	//	Part 3: 更新数据
	writeChange();

	fseek( m_pFile, 0 , SEEK_END ) ;

	return true;
}

bool	t3DModel::reset()
{
	vector<t3DObject*>::iterator iter = m_vObject.begin();
	vector<t3DObject*>::iterator iterEnd = m_vObject.end();
	for ( ; iter != iterEnd; iter++)
	{
		if (*iter)
		{
			delete *iter;
			*iter = NULL;
		}
	}
	m_vObject.clear();

	if(m_puObjPos)
	{
		delete	m_puObjPos;
		m_puObjPos = NULL;
	}

	return true;
}

bool	t3DModel::initilize()
{
	//m_nVersionMod	= VERSION_MOD_CURRENT;//VERSION_MOD(year, updateTime);

	return	true;
}

bool	t3DModel::writeFormat()
{
	// Part 1: 格式信息
	fwrite( m_sFormat, sizeof(m_sFormat), 1, m_pFile);

	// Part 2: 版本信息
	fwrite( &m_nVersionMod, sizeof(unsigned int), 1,m_pFile );
	return true;
}
bool	t3DModel::writeHeader()
{
	//	Part 1: 场景中心坐标
	fwrite( &m_oSceneCenter, sizeof(CVector3), 1, m_pFile);

	int	nObjectCount = (int)m_vObject.size();
	//	Part 1: 物体总数
	fwrite( &nObjectCount, sizeof(int), 1,  m_pFile);

	//	Part 2: 物体位置数组
	m_uiObjPosPos = ftell(m_pFile);   //该位置的内容要变化
	m_puObjPos = new unsigned int[nObjectCount];
	fwrite( m_puObjPos, sizeof(unsigned int) * nObjectCount, 1,  m_pFile);

	//	Part 3: 物体类型（标准、烘焙、关键帧）数组
	if (m_nVersionMod == VERSION_MOD_CURRENT)
	{
		static TraverseVecForWriteObjectTypeInt	vecWriter(m_pFile);
		for_each( m_vObjectType.begin() ,m_vObjectType.end() ,vecWriter );
	}
	else if (m_nVersionMod == VERSION_MOD_LAST)
	{
		//static TraverseVecForWriteObjectType<bool> vecWriter(m_pFile);
		static TraverseVecForWriteObjectTypeBool	vecWriter(m_pFile);
		for_each( m_vIsBaked.begin() ,m_vIsBaked.end() ,vecWriter );
	}
	//static TraverseVecForWriteObjectTypeInt vecWriter(m_pFile);
	//for_each( m_vObjectType.begin() ,m_vObjectType.end() ,vecWriter );

	
	return	true;
}

bool	t3DModel::writeObjects()
{
	int index=0;
	for ( vector<t3DObject*>::iterator iter = m_vObject.begin();
		iter != m_vObject.end(); iter++, index++)
	{
		m_puObjPos[index] = ftell(m_pFile);

		fwrite( &m_uiObjChunkSize , sizeof(unsigned int), 1, m_pFile);

		//	每个物体的静态网格信息
		(*iter)->Write(m_pFile, m_pTheMtls, m_nVersionMod);

		// 更新进度显示
		m_pMaxInterface->ProgressUpdate((int)((float)index / m_vObject.size() * 100.0f)); 
	}

	return	true;
}

bool	t3DModel::writeChange()
{
	unsigned int	uiFilePos = ftell(m_pFile);
	int	nObjectCount = (int)m_vObject.size();

	//	Part 4: 改写文件头， 物体位置
	fseek( m_pFile, m_uiObjPosPos , SEEK_SET);
	fwrite( m_puObjPos , sizeof(unsigned int) * nObjectCount , 1, m_pFile);//写入每个文件块的起始位置；

	//	Part 5: 改写物体头， 每个物体的块大小
	for (int i = 0; i < nObjectCount -1 ; i++)
	{
		m_uiObjChunkSize = m_puObjPos[i+1] - m_puObjPos[i] -4;
		fseek( m_pFile, m_puObjPos[i] , SEEK_SET);
		fwrite( &m_uiObjChunkSize , sizeof(unsigned int) , 1, m_pFile);
	}													//写入前n-1个文件块的长度；

	m_uiObjChunkSize = uiFilePos - m_puObjPos[nObjectCount - 1] -4;
	fseek( m_pFile, m_puObjPos[nObjectCount - 1] , SEEK_SET);
	fwrite( &m_uiObjChunkSize , sizeof(unsigned int) ,1 , m_pFile);

	fseek( m_pFile, 0 , SEEK_END ) ;//写入最后一个文件块的长度；

	return	true;
}
// t3DModel		//////////////////////////////////////////////////////////////////////
